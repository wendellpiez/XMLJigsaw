<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math"
    xmlns:ixsl="http://saxonica.com/ns/interactiveXSLT"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    xmlns:o="http://csrc.nist.gov/ns/oscal/1.0"
    xmlns:pb="http://github.com/wendellpiez/XMLjellsandwich/oscal/validator"
    extension-element-prefixes="ixsl"
    exclude-result-prefixes="#all"
    default-mode="validate"
    >

    <xsl:output indent="yes"/>

    <!-- Imported file provides datatype checking library
         - it is generated from generators/generate-datatype-functions.xsl -->
    <xsl:import href="validate-datatypes.xsl"/>

    <!-- Also see the xsl:include at the end, where 
         autogenerated modules generated from metaschema sources
         provide templates for validations against elements in the respective models. -->
    
    <!-- treat elements in other namespaces as interlopers? -->
    <xsl:variable name="allow-foreign" select="true()"/>
    
    <xsl:variable name="indented-serialization" as="element()">
        <output:serialization-parameters
            xmlns:output="http://www.w3.org/2010/xslt-xquery-serialization">
            <output:indent value="true"/>
        </output:serialization-parameters>
    </xsl:variable>
    
    <xsl:template name="validate-catalog">
        <xsl:result-document href="#bxbody" method="ixsl:append-content">
            <details>
                <summary>XML source</summary>
                <pre id="document-source">
                    <xsl:value-of select="serialize(/,$indented-serialization)"/>
                </pre>
            </details>
            <section class="validation">
                <h3>Annotated tree (with validation findings)</h3>
                <xsl:variable name="validated-tree">
                  <xsl:apply-templates mode="validate"/>
                </xsl:variable>
                <xsl:if test="empty($validated-tree//pb:*)">
                    <h4>Congratulations, there is nothing to report</h4>
                </xsl:if>
                <xsl:apply-templates select="$validated-tree" mode="outline"/>
            </section>
        </xsl:result-document>
    </xsl:template>

    <xsl:mode name="validate" on-no-match="shallow-copy"/>
    
    <xsl:mode name="validate-markup-line" on-no-match="shallow-skip"/>
    <xsl:mode name="validate-markup-multiline" on-no-match="shallow-skip"/>
    
    <xsl:template match="*" mode="validate">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates select="." mode="test"/>
            <xsl:apply-templates mode="validate"/>
        </xsl:copy>
    </xsl:template>

    <!-- wrapper template for testing on each node, to be overridden
         and extended for known elements -->
    <xsl:template match="*" mode="test">
        <!-- report if not recognized -->
        <xsl:call-template name="notice">
            <xsl:with-param name="cat">unknown element</xsl:with-param>
            <xsl:with-param name="msg" expand-text="true">Element <code>{ name() }</code> not recognized.</xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    
    <xsl:template match="*" mode="validate-markup-multiline">
        <!-- report if not recognized -->
        <xsl:call-template name="notice">
            <xsl:with-param name="cat">unknown element</xsl:with-param>
            <xsl:with-param name="msg" expand-text="true">Element <code>{ name() }</code> not recognized in multiline markup.</xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    
    <xsl:template match="*" mode="validate-markup-line">
        <!-- report if not recognized -->
        <xsl:call-template name="notice">
            <xsl:with-param name="cat">unknown element</xsl:with-param>
            <xsl:with-param name="msg" expand-text="true">Element <code>{ name() }</code> not recognized in markup.</xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    
    <!-- ... and attributes ...  -->
    <xsl:template match="@*" mode="test validate-markup-line validate-markup-multiline">
        <xsl:call-template name="notice">
            <xsl:with-param name="cat">unknown attribute</xsl:with-param>
            <xsl:with-param name="msg" expand-text="true">Attribute <code>@{ name() }</code> not recognized on parent <code>{ name(..) }</code> .</xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    
    <xsl:template mode="test" match="@xsi:*" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>

    <xsl:template name="notice">
        <xsl:param name="condition" as="xs:boolean" select="true()"/>
        <xsl:param name="cat" as="xs:string">[category]</xsl:param>
        <xsl:param name="msg">[info]</xsl:param>
        <xsl:if test="$condition">
            <xsl:variable name="xpath">
                <xsl:apply-templates select="." mode="xpath"/>
            </xsl:variable>
            <pb:z cat="{$cat}" xpath="{ $xpath }">
                <xsl:sequence select="$msg"/>
            </pb:z>
        </xsl:if>
    </xsl:template>
    
    <xsl:template mode="xpath" match="*">
        <xsl:apply-templates select="parent::*" mode="#current"/>
        <xsl:text expand-text="true">/{ name() }</xsl:text>
    </xsl:template>
    
    <xsl:template mode="xpath" match="*[node-name()=(../* except current() )/node-name()]">
        <xsl:apply-templates select="parent::*" mode="#current"/>
        <xsl:variable name="predecessors" select="preceding-sibling::*[node-name()=current()/node-name()]"/>
        <xsl:text expand-text="true">/{ name() }[{ pb:element-position(.) }]</xsl:text>
    </xsl:template>
    
    <xsl:template mode="xpath" match="@*">
        <xsl:apply-templates select="parent::*" mode="#current"/>
        <xsl:text expand-text="true">/@{ name() }</xsl:text>
    </xsl:template>
    
    <xsl:template match="*" mode="outline" expand-text="true">
        <div class="outline">
            <div class="oll">{ name() }</div>
            <div class="olc">
                <xsl:apply-templates mode="outline"/>
            </div>
        </div>
    </xsl:template>
    
    <xsl:template match="pb:z" mode="outline" expand-text="true">
        <div class="report">
            <p class="title">{ @cat }</p>
            <p class="problematic">
              <xsl:copy-of select="node()"/>
            </p>
            <p class="xpath">{ @xpath }</p>
        </div>
    </xsl:template>
    
    <!-- <xsl:template match="*[exists(child::text()[matches(.,'\S')])]" mode="outline" expand-text="true">
        <div class="oll">{ name() }</div>
        <xsl:apply-templates mode="outline"/>
    </xsl:template> -->
    
    <xsl:template match="text()[matches(.,'^\s+$')]" mode="outline"/>
    
    <xsl:template match="text()" mode="outline" expand-text="true">
        <!-- <div class="olt" style="width: { normalize-space(.) ! string-length(.) }; flex-basis: { normalize-space(.) ! string-length(.) }">&#xA0;</div> -->
        <div class="olt">{ normalize-space(.) }</div>
    </xsl:template>
   
    <xsl:template name="check-datatype">
        <xsl:apply-templates select="." mode="test-datatype"/>
    </xsl:template>
    
    <xsl:template mode="test-datatype" match="*"/>
   
    <xsl:function name="pb:element-position" as="xs:positiveInteger">
        <xsl:param name="for" as="element()"/>
        <xsl:variable name="qname" select="node-name($for)"/>
        <xsl:sequence select="count(($for | $for/preceding-sibling::*)[node-name() = $qname])"/>
    </xsl:function>
   
    <xsl:template name="check-markup-line-datatype">
        <xsl:apply-templates mode="validate-markup-line"/>
    </xsl:template>
    
    <xsl:template name="check-markup-multiline-datatype">
        <xsl:apply-templates mode="validate-markup-multiline"/>
    </xsl:template>
   
    <!-- autogenerated modules generated from metaschema sources
         provide templates for validations against elements in the respective models. -->
    
    <xsl:include href="catalog-validate.xsl"/>
    
    
</xsl:stylesheet>
